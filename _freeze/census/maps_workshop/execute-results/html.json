{
  "hash": "24588a439b6be2a19f1b663172ddb735",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R Workshop: Geographic and Demographic Data Analysis and Visualization\"\nauthor: \"Michelle Bueno Vásquez\"\ndate: today\nformat:\n  html:\n    toc: true\n    embed-resources: true\n    code-tools: true\n    link-external-newwindow: true\n    fig-dpi: 300\nexecute:\n  echo: true\n  warning: false\n  message: false\n  cache: TRUE\n  \nfrom: markdown+emoji \n---\n\n\n\n\n\n# Welcome! :world_map:\n\n::: callout-tip\n## Setting up a Census API Key\n\nBefore we get started, I will have you all go ahead and request a Census API key which will allow us to access Census data for our analyses. It takes about 2-5 minutes to send, so let's get started with this while we chat a little about spatial data :blush:\n:::\n\n# Step-by-Step Instructions for Getting a Census API Key for `tidycensus`\n\nThe U.S. Census Bureau provides an API that allows users to access various datasets, including the American Community Survey (ACS) and the Decennial Census. To use `tidycensus` in R, you'll need to obtain and register an API key.\n\n### Request a Census API Key\n\n1.  [**Go to the U.S. Census API Key Request Page:**](https://api.census.gov/data/key_signup.html)\n\n2.  **Fill out the form:**\n\n    -   Enter your name\n    -   Enter your email address\n    -   Agree to the terms of service\n\n3.  **Submit the request.**\\\n    You will receive an API key via email (a long alphanumeric string).\n\n------------------------------------------------------------------------\n\n# Introduction to Geospatial Data in R\n\n## **What is Geospatial Data?**\n\n*Geospatial data* refers to any data that has a geographic component, meaning it is tied to specific locations on the Earth's surface. This data is used in mapping, spatial analysis, and geographic visualization.\n\nThere are two primary types of geospatial data:\\\n1. **Vector Data**: Represents geographic features as points, lines, or polygons.\\\nExamples:\\\n- **Points**: Locations of schools, stores, or crime incidents\\\n- **Lines**: Roads, rivers, or flight paths\\\n- **Polygons**: State boundaries, land parcels, Census tracts\n\n2.  **Raster Data**: Represents spatial data as a grid of pixels, commonly used for continuous data like elevation, temperature, and satellite imagery.\n    -   Example: A satellite image of land cover, where each pixel represents vegetation, water, or urban areas.\n\n## **Common Geospatial Data Formats**\n\nDifferent formats are used to store and exchange geospatial data. Some of the most common include:\n\n-   **Shapefiles (.shp)** -- A widely used vector format consisting of multiple files that store geometry and attribute data.\\\n-   **GeoJSON (.geojson)** -- A JSON-based format for encoding spatial data, commonly used for web mapping.\\\n-   **KML (.kml)** -- A format developed by Google for geographic visualization in Google Earth and Maps.\\\n-   **Census Data (via API or TIGER/Line Shapefiles)** -- Demographic and boundary data provided by the U.S. Census Bureau.\n\n# Overview of Key R Packages for Geospatial Data\n\nR provides powerful packages for working with geospatial data. Here are the key ones we'll use in this workshop:\n\n### `sf` (Simple Features)\n\n-   Provides a modern approach to handling vector geospatial data in R.\n\n-   Replaces older packages like `sp` and `rgdal`.\n\n-   Supports reading, writing, and manipulating spatial data.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install the package `sf`\n# install.packages(\"sf\")\n\n# Load the package\nlibrary(sf)\n```\n:::\n\n\n\n\n\n### `tigris`\n\n-   Retrieves geographic boundary data from the U.S. Census Bureau (e.g., states, counties, tracts).\n\n-   Works with `sf` for mapping and spatial analysis.\n\n**Example:** Download state boundaries\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages('tigris')\nlibrary(tigris)\n\n# We can download boundary data for the US states\nstates_sf <- states(cb = TRUE,\n                    resolution = \"20m\",\n                    progress_bar = FALSE)\n```\n:::\n\n\n\n\n\n### `maps`\n\n-   Provides simple built-in maps for U.S. states, counties, and world boundaries.\n\n-   Useful for quick visualizations.\n\n**Example:** Plot a basic map of the U.S.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install 'maps'\n# install.packages('maps')\n\n# Load maps alone with tidyverse to access ggplot\nlibrary(tidyverse)\nlibrary(maps)\n\n# Download U.S. map data\nus_states <- map_data(\"state\")\n\n# Plot the U.S. map\nggplot(us_states, \n       aes(long, lat, \n           group = group)) + \n  geom_polygon(fill = \"lavender\", \n               color = \"black\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](maps_workshop_files/figure-html/unnamed-chunk-3-1.png){width=2100}\n:::\n:::\n\n\n\n\n\nThis is great, but we're missing Alaska, Hawaii, Puerto Rico, etc. We can use `tigris` instead for the same purposes.\n\n### `ggplot2`'s `geom_sf` for Geospatial Visualization\n\n-   `geom_sf()` allows for powerful mapping of spatial data.\n-   Enables custom styling and integration with non-spatial data.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's plot this using the `sf` object from tigris\nggplot(states_sf) +\n    geom_sf(fill = \"lavender\", color = \"black\")\n```\n\n::: {.cell-output-display}\n![](maps_workshop_files/figure-html/unnamed-chunk-4-1.png){width=2100}\n:::\n:::\n\n\n\n\n\nBut notice how our map looks very tiny and spread out. :scream:: That is because the shape file is using raw longitude and latitude. Since this plot is very hard to read, we can use a transformation to shift the non-continental U.S. territories near the rest of the U.S.:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We'll use the `tigris` function `shift_geometry` when saving the states file\nstates_sf <- states(cb = TRUE,\n                    resolution = \"20m\") %>% \n  shift_geometry()\n\n# Now we can try plotting again:\nggplot(states_sf) +\n    geom_sf(fill = \"lavender\", \n            color = \"black\") \n```\n\n::: {.cell-output-display}\n![](maps_workshop_files/figure-html/unnamed-chunk-5-1.png){width=2100}\n:::\n:::\n\n\n\n\n\nI like to add `theme_void` to get rid of those coordinate lines:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We'll use the `tigris` function `shift_geometry` when saving the states file\nstates_sf <- states(cb = TRUE,\n                    resolution = \"20m\") %>% \n  shift_geometry()\n\n# Now we can try plotting again:\nggplot(states_sf) +\n    geom_sf(fill = \"lavender\", \n            color = \"black\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](maps_workshop_files/figure-html/unnamed-chunk-6-1.png){width=2100}\n:::\n:::\n\n\n\n\n\n## **Summary**\n\n-   **Geospatial data** is any data with a geographic component, stored in vector (points, lines, polygons) or raster (grids) formats.\n-   **Common formats** include Shapefiles, GeoJSON, KML, and Census data.\n-   **Key R packages**:\n    -   `sf` for spatial data manipulation.\n    -   `tidycensus` for retrieving Census data.\n    -   `tigris` for downloading geographic boundaries.\n    -   `maps` for built-in map data.\n    -   `ggplot2` for visualization.\n\n## Exercise: plot your home state and city\n\nI'll do the same for Illinois and Chicago\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the data for IL counties\n# get data\nil_counties <- map_data(\"county\", \"illinois\") %>% \n  select(lon = long, lat, group, id = subregion)\n\n\n# Chicago and Evanston lon and lat (looked it up on Google)\n# Chicago: 41.8781° N, -87.6298° W\n# Evanston: 42.0521° N, -87.6848° W\nil_city_data <- tibble(\n  city_name = c(\"Chicago\", \"Evanston\"),\n  lon = c(-87.6298, -87.6848),\n  lat = c(41.8781, 42.0521)\n)\n\n\n# Make map with cities\nggplot(il_counties, aes(lon, lat)) +\n  geom_polygon(aes(group = group), \n               fill = \"slateblue\", \n               col = 'grey50') +\n  ggstar::geom_star(data = il_city_data, \n                    size = 4,\n                    fill = \"gold\",\n                    mapping = aes(fill = city_name)) +\n geom_label(data = il_city_data, \n            aes(label = city_name), \n            nudge_x = c(-.5, -.8),\n            nudge_y = c(-.3, 0),\n            size = 3.2) +\n  coord_quickmap() +\n  theme_void() +\n  ggtitle(\"Illinois: the Lincoln State\") \n```\n\n::: {.cell-output-display}\n![](maps_workshop_files/figure-html/unnamed-chunk-7-1.png){width=2100}\n:::\n:::\n\n\n\n\n\n## YOUR TURN :raised_hands: :\n\n## Using my code above as a guide, plot your home state/any state of your choosing and its capital and/or your home town.\n\n------------------------------------------------------------------------\n\n# Using tidycensus for Census Data Retrieval and Visualization\n\n## What is tidycensus?\n\nThe tidycensus package is an R interface to the U.S. Census Bureau API. It is useful for mapping, analyzing, and visualizing demographic data in R.\n\nIt allows users to retrieve demographic and socioeconomic data from:\n\n-   The American Community Survey (ACS) (yearly estimates)\n-   The Decennial Census (10-year population counts)\n-   Other Census datasets\n\nHere are a few of the commands you can use to access Census Bureau products:\n\n-   `get_acs()`, which requests data from the 1-year and 5-year **American Community Survey** samples. Data are available from the 1-year ACS back to 2005 and the 5-year ACS back to 2005-2009.\n\n-   `get_estimates()`, an interface to the **Population Estimates** APIs. These datasets include yearly estimates of population characteristics by state, county, and metropolitan area, along with components of change demographic estimates like births, deaths, and migration rates.\n\n-   `get_flows()`, an interface to the ACS **Migration Flows** APIs. Includes information on in- and out-flows from various geographies for the 5-year ACS samples, enabling origin-destination analyses.\n\n-   `get_pums()`, which accesses data from the ACS **Public Use Microdata** Sample APIs. These samples include anonymized individual-level records from the ACS organized by household and are highly useful for many different social science analyses.[^1]\n\n[^1]: Source: *Analyzing US Census Data: Methods, Maps, and Models in R* by Kyle Walker\n\n## Install and Load `tidycensus` in R\n\nYou should have received a Census API key to the email you entered earlier.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install the `tidycensus`\n# install.packages(\"tidycensus\")\n\n# Load the package\nlibrary(tidycensus)\n\n### Register API key \n## Option 1: temporary, save it only for this session \n## (delete # in front of the following line when ready to run code)\n\n# census_api_key(\"YOUR_API_KEY_HERE\")\n\n# Option 2 (my recommendation): Save the API Key for Future Use \n## to avoid entering the key every time, store it permanently: \n## (delete # in front of the following line when ready to run code)\n\n# census_api_key(\"YOUR_API_KEY_HERE\", install = TRUE)\n```\n:::\n\n\n\n\n\nReplace `\"YOUR_API_KEY_HERE\"` with the key you received.\n\nOption 2 will save the key to your `.Renviron` file, so it loads automatically in future R sessions. Restart R for the change to take effect.\n\n## Getting ACS Data\n\n**The ACS** provides yearly estimates on income, education, race, and other demographics. Use `get_acs()` to retrieve ACS data.\n\n-   Example: Get median household income by state for 2024\n\n### Let's get some ACS data and test the API Key\n\nTo verify that the key is working, try fetching some ACS (American Community Survey) data.\n\nFirst, let's load the variables in the ACS for the year we'd like to gather data from. We use the call `load_variables`\n\nWe can also find them listed on the [Census website](https://api.census.gov/data/2023/acs/acs5/profile/variables.html)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load variable list\nvars23 <- load_variables(2023, \"acs5\", cache = TRUE)\n\n# We can take a look and search for variables of interest\nview(vars23)\n```\n:::\n\n\n\n\n\nBut as you can see, it can be overwhelming to search. Here is a trick to quicken our search:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's filter all variables with 'median household income' in the label column\nincome_vars <- vars23 %>% \n    filter(grepl('median household income', label, ignore.case = TRUE))\n\nview(income_vars)\n```\n:::\n\n\n\n\n\nThe variable `B19013_001` with label `Estimate!!Median household income in the past 12 months (in 2023 inflation-adjusted dollars)` and concept `Median Household Income in the Past 12 Months (in 2023 Inflation-Adjusted Dollars)` looks perfect for our needs.\n\nNow that we know our variable of interest, let's define our ACS call by state for 2023:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Using the get_acs function, we can get Census data for specific geogprahies and specific variables\ndf <- get_acs(geography = \"state\", \n              variables = \"B19013_001\",  # Median Household Income\n              year = 2023,\n              progress_bar = FALSE)\n\n# Let's take a sneak peak of our data frame\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  GEOID NAME       variable   estimate   moe\n  <chr> <chr>      <chr>         <dbl> <dbl>\n1 01    Alabama    B19013_001    62027   400\n2 02    Alaska     B19013_001    89336  1374\n3 04    Arizona    B19013_001    76872   414\n4 05    Arkansas   B19013_001    58773   503\n5 06    California B19013_001    96334   298\n6 08    Colorado   B19013_001    92470   483\n```\n\n\n:::\n:::\n\n\n\n\n\n::: call-out.tip\nIf the data loads without errors, your API key is successfully set up!\n:::\n\nThe dataset includes:\n\n-   GEOID (geographic ID)\n-   NAME (state name)\n-   estimate (median income value)\n-   moe (margin of error)\n\n## Combining Census Data with Geospatial Data\n\nWe can skip a step by requesting geographic data simultaneously with Census data, using the argument `geometry = TRUE`\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nincome_sf <- get_acs(geography = \"state\", \n                     variables = c(median_income = \"B19013_001\"), \n                     year = 2023, \n                     geometry = TRUE,\n                     progress_bar = FALSE) %>% # Get spatial data\n              shift_geometry()            # Don't forget or else we get a weird map!\n```\n:::\n\n\n\n\n\nNow we can create different types of visualizations\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(income_sf) +\n  geom_sf(aes(fill = estimate), \n          color = \"white\") +\n  scale_fill_viridis_c(option = \"magma\", \n                       name = \"Median Income\") +\n  theme_void() +\n  labs(title = \"Median Household Income by State (2023)\",\n       caption = \"Source: U.S. Census Bureau ACS 2023\\n*note: Puerto Rico not included\")\n```\n\n::: {.cell-output-display}\n![](maps_workshop_files/figure-html/unnamed-chunk-13-1.png){width=2100}\n:::\n:::\n\n\n\n\n\nKey Features of this Plot:\n\n-   `aes(fill = estimate)` colors states by income\n-   `scale_fill_viridis_c()` improves color contrast\n-   `theme_minimal()` gives a clean look\n\nOkay, the map looks good but that scaling on the legend is kind of ugly.\n\nLet's fix that:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install and load the 'scales' library\n# install.packages('scales')\nlibrary(scales)\n\n# Plot with pretty numbers\noptions(scipen = 999)        # this will prevent the plots from producing a default scientific notation \n\nggplot(income_sf) +\n  geom_sf(aes(fill = estimate), \n          color = \"white\") +\n  scale_fill_viridis_c(option = \"magma\", \n                       name = \"Median Income\",\n                       labels = scales::comma) +    # this will add  a comma for thousands\n  theme_void() +\n  labs(title = \"Median Household Income by State (2023)\",\n       caption = \"Source: U.S. Census Bureau ACS 2023\\n*note: Puerto Rico not included\")\n```\n\n::: {.cell-output-display}\n![](maps_workshop_files/figure-html/unnamed-chunk-14-1.png){width=2100}\n:::\n:::\n\n\n\n\n\n## Top states by income\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_income <- income_sf %>%\n  arrange(desc(estimate)) %>%\n  slice(1:10)\n\nggplot(top_income, aes(x = reorder(NAME, estimate), y = estimate)) +\n  geom_col(fill = \"steelblue\") +\n  coord_flip() +  # Flip for readability\n  theme_minimal() +\n  scale_y_continuous(labels = scales::comma) +       # same scale trick, but note we use `scale_y_continuous` since this time we are targeting the x-axis\n  labs(title = \"Top 10 States by Median Income (2023)\",\n       x = \"State\", y = \"Median Income\",\n       caption = \"Source: U.S. Census Bureau ACS 2023\")\n```\n\n::: {.cell-output-display}\n![](maps_workshop_files/figure-html/unnamed-chunk-15-1.png){width=2100}\n:::\n:::\n\n\n\n\n\n## YOUR TURN :raised_hands: :\n\n## Choose another variable of interest and gather Census ACS data & plot it using the above code as a guide\n\n### Common ACS Variables\n\nHere are a few frequently used variables:\n\n| Variable Name | Description                    |\n|:--------------|:-------------------------------|\n| B19013_001    | Median Household Income        |\n| B17001_002    | Population Below Poverty Level |\n| B25077_001    | Median Home Value              |\n| B01003_001    | Total Population               |\n| B03002_003    | Non-Hispanic White Population  |\n| B03002_004    | Black Population               |\n| B03002_012    | Hispanic or Latino Population  |\n\nHere are other examples of useful variables:\n\n1.  Demographic Analysis (Population by Race, Ethnicity, Age, Gender)\n\n| Variable Name | Description                          |\n|:--------------|:-------------------------------------|\n| B01003_001    | Total Population                     |\n| B01002_001    | Median Age                           |\n| B01001_002    | Male Population                      |\n| B01001_026    | Female Population                    |\n| B03002_003    | Non-Hispanic White Population        |\n| B03002_004    | Black or African American Population |\n| B03002_012    | Hispanic or Latino Population        |\n| B03002_006    | Asian Population                     |\n\n: :small_orange_diamond: Use Case: Population distributions, racial/ethnic composition, gender breakdowns.\n\n2.  Socioeconomic Status (SES) & Income Inequality\n\n| Variable Name            | Description                    |\n|:-------------------------|:-------------------------------|\n| B19013_001               | Median Household Income        |\n| B19001_002 -- B19001_017 | Household Income Brackets      |\n| B17001_002               | Population Below Poverty Level |\n| B19301_001               | Per Capita Income              |\n| B25077_001               | Median Home Value              |\n| B25064_001               | Median Gross Rent              |\n\n: :small_orange_diamond: Use Case: Economic disparities, income inequality, housing affordability.\n\n3.  Education & Employment\n\n| Variable Name | Description                 |\n|:--------------|:----------------------------|\n| B15003_022    | Bachelor's Degree or Higher |\n| B15003_017    | High School Graduates       |\n| B23025_002    | Civilian Labor Force        |\n| B23025_005    | Unemployment Count          |\n| B23025_007    | Unemployment Rate           |\n\n: :small_orange_diamond: Use Case: Workforce analysis, educational attainment, economic mobility.\n\n4.  Housing & Urban Development\n\n| Variable Name | Description                 |\n|:--------------|:----------------------------|\n| B25077_001    | Median Home Value           |\n| B25064_001    | Median Gross Rent           |\n| B25034_001    | Housing Units by Year Built |\n| B25002_003    | Vacant Housing Units        |\n| B25024_002    | Single-Family Homes         |\n| B25024_010    | Mobile Homes                |\n\n: :small_orange_diamond: Use Case: Gentrification studies, housing affordability, displacement trends.\n\n5.  Health & Disability\n\n| Variable Name | Description                               |\n|:--------------|:------------------------------------------|\n| B18101_001    | Population with a Disability              |\n| B27010_001    | Population with Health Insurance Coverage |\n| B27010_017    | Population Uninsured                      |\n| B25099_001    | Households with No Plumbing Facilities    |\n\n: :small_orange_diamond: Use Case: Healthcare access, disability prevalence, environmental health.\n\n## Using state bins\n\nThis is another approach for data visualization of state data where we ditch the state's natural shape to emphasize comparisons among them.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install and load 'statebins'\n# install.packages('statebins')\nlibrary(statebins)\n\n\n# Using the income dataframe from earlier, let's add income levels\nUS_income <- mutate(\n  income_sf,\n  income_bins = cut(\n    ifelse(is.na(estimate), 25000, estimate),\n    breaks = c(0, 40000, 50000, 60000, 70000, 80000, 150000),\n    labels = c(\"< $40k\", \"$40k to $50k\", \n               \"$50k to $60k\", \"$60k to $70k\", \"$70k - $80k\", \" > $80k\"),\n    right = FALSE\n  )\n)\n\n# Plotting\nUS_income %>% \n  ggplot() +\n  statebins::geom_statebins(aes(geometry = geometry,\n                                state = NAME, \n                                fill = income_bins)) +\n  scale_fill_viridis_d() +\n  theme_statebins() +\n  labs(title = \"Median Household Income by State (2023)\",\n       caption = \"Source: U.S. Census Bureau ACS 2023. Note: Puerto Rico not included\")\n```\n\n::: {.cell-output-display}\n![](maps_workshop_files/figure-html/unnamed-chunk-16-1.png){width=2100}\n:::\n:::\n\n\n\n\n\n# Advanced example: using multiple variables at once\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's gather data for income and poverty for states in 2023\ndata <- get_acs(geography = \"state\", \n                variables = c(income = \"B19013_001\", \n                              poverty = \"B17001_002\",\n                              population = \"B01003_001\"),\n                year = 2023,\n                geometry = TRUE,\n                progress_bar = FALSE) %>% \n  shift_geometry()\n\nhead(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -1233579 ymin: -614973.5 xmax: -35340.83 ymax: 970427.9\nProjected CRS: USA_Contiguous_Albers_Equal_Area_Conic\n  GEOID         NAME   variable estimate  moe                       geometry\n1    35   New Mexico population  2114768   NA MULTIPOLYGON (((-1231344 -5...\n2    35   New Mexico    poverty   375381 7817 MULTIPOLYGON (((-1231344 -5...\n3    35   New Mexico     income    62125  608 MULTIPOLYGON (((-1231344 -5...\n4    46 South Dakota population   899194   NA MULTIPOLYGON (((-633765.6 8...\n5    46 South Dakota    poverty   104511 3107 MULTIPOLYGON (((-633765.6 8...\n6    46 South Dakota     income    72421  805 MULTIPOLYGON (((-633765.6 8...\n```\n\n\n:::\n:::\n\n\n\n\n\nNotice how our variables are all listed under the variable column. For our analyses, it would be fruitful to have the variables as their own columns. \n\nTo do this, we will pivot the data long-ways so that each variable is its own column.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Transpose the data so each variable has its own column}\ndata_wide <- data %>%\n  select(GEOID,\n         state = NAME, \n         variable, \n         estimate, \n         geometry) %>%  # Keep relevant columns\n  distinct(GEOID, \n           state, \n           variable, \n           estimate, \n           .keep_all = TRUE) %>%  # Remove duplicate rows\n  pivot_wider(\n    names_from = variable,\n    values_from = estimate\n  ) %>% \n  mutate(poverty_rate = (poverty / population) * 100)  # Compute Poverty Rate\n\n# Let's look at our new data set:\nhead(data_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -2356114 ymin: -782290.7 xmax: 1419556 ymax: 970427.9\nProjected CRS: USA_Contiguous_Albers_Equal_Area_Conic\n# A tibble: 6 × 7\n  GEOID state                    geometry population poverty income poverty_rate\n  <chr> <chr>          <MULTIPOLYGON [m]>      <dbl>   <dbl>  <dbl>        <dbl>\n1 35    New Me… (((-1231344 -588235.8, -…    2114768  375381  62125         17.8\n2 46    South … (((-633765.6 865552.6, -…     899194  104511  72421         11.6\n3 06    Califo… (((-2066923 -203083.1, -…   39242785 4610600  96334         11.7\n4 21    Kentuc… (((584560 -88603.17, 585…    4510725  707480  62417         15.7\n5 01    Alabama (((760323.7 -749311.5, 7…    5054253  768185  62027         15.2\n6 13    Georgia (((1390722 -584139.2, 13…   10822590 1423159  74664         13.1\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install package`RColorBrewer`\n# install.packages('RColorBrewer')\n\nlibrary(RColorBrewer)  # For color scales\n\n# Define breaks using quantiles\nincome_breaks <- quantile(data_wide$income, \n                          probs = seq(0, 1, length.out = 4), \n                          na.rm = TRUE)\npoverty_breaks <- quantile(data_wide$poverty_rate, \n                           probs = seq(0, 1, length.out = 4), \n                           na.rm = TRUE)\n\n\n# Define bivariate color scale using ColorBrewer\nbivariate_palette <- c(\n  \"Low-Low\" = brewer.pal(9, \"PuBuGn\")[1],  # Light green\n  \"Low-Medium\" = brewer.pal(9, \"PuBuGn\")[3],\n  \"Low-High\" = brewer.pal(9, \"PuBuGn\")[5],\n  \"Medium-Low\" = brewer.pal(9, \"Purples\")[3],\n  \"Medium-Medium\" = brewer.pal(9, \"Purples\")[5],\n  \"Medium-High\" = brewer.pal(9, \"Purples\")[7],\n  \"High-Low\" = brewer.pal(9, \"Oranges\")[3],\n  \"High-Medium\" = brewer.pal(9, \"Oranges\")[5],\n  \"High-High\" = brewer.pal(9, \"Oranges\")[7]   # Dark orange\n)\n\n\n# Assign colors to the dataset\ndata_wide <- data_wide %>%\n  mutate(\n    income_cat = cut(income, \n                     breaks = quantile(income, \n                                       probs = seq(0, 1, length.out = 4), \n                                       na.rm = TRUE), \n                     labels = c(\"Low\", \"Medium\", \"High\"), \n                     include.lowest = TRUE),\n    poverty_cat = cut(poverty_rate, \n                      breaks = quantile(poverty_rate, \n                                        probs = seq(0, 1, length.out = 4), \n                                        na.rm = TRUE), \n                      labels = c(\"Low\", \"Medium\", \"High\"), \n                      include.lowest = TRUE),\n    category = paste(income_cat, \n                     poverty_cat, \n                     sep = \"-\")  # Create bivariate categories\n  )\n\n\n# Create plot\n\nggplot(data_wide) +\n  geom_sf(aes(fill = category), \n          color = \"white\", \n          size = 0.2) +\n  scale_fill_manual(values = bivariate_palette, \n                    name = \"Income-Poverty Scale\") +  # Add legend\n  theme_void() +\n  labs(\n    title = \"Income & Poverty Rate by U.S. State (2023)\",\n    subtitle = \"Bivariate Choropleth Map\",\n    caption = \"Source: U.S. Census Bureau ACS 2023\"\n  )\n```\n\n::: {.cell-output-display}\n![](maps_workshop_files/figure-html/unnamed-chunk-19-1.png){width=2100}\n:::\n:::\n\n\n\n\n\n# Using Census data with other data sources\n\nCensus data can be used alongside other political data sources (such as ANES, election data, or even your own survey or qualitative data)!\n\n## Let's use the income-poverty data and compare it to red vs blue states.\n\nFirst let's make a data frame with the states and their respective 2024 vote\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Using data from Politico on 2024 Presidential election\n\n#red_states ~ \"#fb5c44\"\n#blue_states ~ \"#336fba\"\n\nstate_colors <- c(\"Idaho\" = \"#fb5c44\",\n                \"Montana\" = \"#fb5c44\",\n                \"North Dakota\" = \"#fb5c44\",\n                \"South Dakota\" = \"#fb5c44\",\n                \"Wyoming\" = \"#fb5c44\",\n                \"Utah\" = \"#fb5c44\",\n                \"Nebraska\" = \"#fb5c44\",\n                \"Kansas\" = \"#fb5c44\",\n                \"Oklahoma\" = \"#fb5c44\",\n                \"Texas\" = \"#fb5c44\",\n                \"Louisiana\" = \"#fb5c44\",\n                \"Mississippi\" = \"#fb5c44\",\n                \"Alabama\" = \"#fb5c44\",\n                \"Iowa\" = \"#fb5c44\",\n                \"Missouri\" = \"#fb5c44\",\n                \"Arkansas\" = \"#fb5c44\",\n                \"Tennessee\" = \"#fb5c44\",\n                \"Kentucky\" = \"#fb5c44\",\n                \"Indiana\" = \"#fb5c44\",\n                \"Ohio\" = \"#fb5c44\",\n                \"Nevada\" = \"#fb5c44\",\n                \"Arizona\" = \"#fb5c44\",\n                \"Pennsylvania\" = \"#fb5c44\",\n                \"Georgia\" = \"#fb5c44\",\n                \"Michigan\" = \"#fb5c44\",\n                \"Wisconsin\" = \"#fb5c44\",\n                \"West Virginia\" = \"#fb5c44\",\n                \"North Carolina\" = \"#fb5c44\",\n                \"South Carolina\" = \"#fb5c44\",\n                \"Florida\" = \"#fb5c44\",\n                \"Alaska\" = \"#fb5c44\",\n                \"Washington\" = \"#336fba\",\n                 \"Oregon\" = \"#336fba\",\n                 \"California\" = \"#336fba\",\n                 \"Colorado\" = \"#336fba\",\n                 \"New Mexico\" = \"#336fba\",\n                 \"Minnesota\" = \"#336fba\",\n                 \"Massachusetts\" = \"#336fba\",\n                 \"Illinois\" = \"#336fba\",\n                 \"Virginia\" = \"#336fba\",\n                 \"Maryland\" = \"#336fba\",\n                 \"District Of Columbia\" = \"#336fba\",\n                 \"Connecticut\" = \"#336fba\",\n                 \"Rhode Island\" = \"#336fba\",\n                 \"Delaware\" = \"#336fba\",\n                 \"Maine\" = \"#336fba\",\n                 \"New York\" = \"#336fba\",\n                 \"New Jersey\" = \"#336fba\",\n                 \"Hawaii\" = \"#336fba\",\n                 \"New Hampshire\" = \"#336fba\",\n                 \"Vermont\" = \"#336fba\"\n                 )\n\ncolor_vote <- as.data.frame(state_colors)\n\ncolor_vote <- tibble::rownames_to_column(color_vote, \"state\")\n```\n:::\n\n\n\n\n\nNext, let's modify the data set to sort by top poverty rate and income, respectively, and make two different plots\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's plot poverty rate and income\npoverty_colors <- \n  # let's join the data sets while also sorting by top poverty rate\n  data_wide %>% \n  inner_join(color_vote, by = \"state\") %>% \n  filter(state != \"Puerto Rico\") %>% \n  mutate_if(is.numeric, round, 2) %>% \n  top_n(10, poverty_rate) %>% \n  # Now we can plot\n  ggplot(aes(x = reorder(state, poverty_rate), \n               y = poverty_rate,\n             fill = state_colors)) +\n  geom_col() +\n  scale_fill_manual(\n    name = \"2024 Presidential Election Result\",\n    labels = c(\"Blue\", \"Red\"),\n    values = c(\"#336fba\",\"#fb5c44\"),\n    guide = \"none\"\n  ) +\n  coord_flip() +\n  geom_text(aes(label = poverty_rate), \n            color = \"white\",\n            hjust = 1.1,\n            size = 3) +\n  theme_bw()  +\n  labs(\n    y = \"Poverty Rate\",\n    title = 'Top 10 states by poverty rate\\n& 2024 Presidential vote'\n  ) +\n  theme(\n        axis.title.y = element_blank(),\n        axis.ticks.x = element_blank())\n\nincome_colors <-  \n  # let's join the data sets while also sorting by top income\n  data_wide %>% \n  inner_join(color_vote, by = \"state\") %>% \n  filter(state != \"Puerto Rico\") %>% \n  mutate_if(is.numeric, round, 2) %>% \n  top_n(10, income) %>% \n  # Now we can plot\n  ggplot(aes(x = reorder(state, income), \n               y = income,\n             fill = state_colors)) +\n  geom_col() +\n  scale_fill_manual(\n    name = \"2024 Presidential Election Result\",\n    labels = c(\"Blue\", \"Red\"),\n    values = c(\"#336fba\",\"#fb5c44\"),\n    guide = \"none\"\n  ) +\n  scale_y_continuous(labels = scales::comma) +\n  coord_flip() +\n  geom_text(aes(label = scales::comma(income)), \n            color = \"white\",\n            hjust = 1.1,\n            size = 3) +\n  theme_bw()  +\n  labs(\n    y = \"Median Household Income\",\n    title = 'Top 10 states by income\\n& 2024 Presidential vote',\n    caption = \"\\nU.S. Census Bureau 2023 ACS 5-Year Population Estimates \\n Politico 2024 Election Mapping.\"\n  ) +\n  theme(\n        axis.title.y = element_blank(),\n        axis.ticks.x = element_blank())\n```\n:::\n\n\n\n\n\nFinally, let's view these plots side by side and see if there are interesting conclusions we can make about the interactions between poverty/income and 2024 vote choice.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install patchwork to view these side by side\n# install.packages('patchwork')\nlibrary(patchwork)\n\npoverty_colors + income_colors\n```\n\n::: {.cell-output-display}\n![](maps_workshop_files/figure-html/unnamed-chunk-22-1.png){width=2100}\n:::\n:::\n\n\n\n\n\n## YOUR TURN :raised_hands: : Using the color_vote data from the 2024 election, find another variable you are interested in to visualize along with vote choice.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}